algorithm
5.23
dynamic programming 
question 62 unique paths 
	create a matrix, mark the value in the spot

5.26
dnamic programming 
question 63 unique paths two
	same as the question 62, mark 0 when meet the block
	O(n^2)

question 64 Minimum path sum 
	same as the question 62,63 
	O(n^2)

question 10 regular expression matching
	create a matrix, if character same mark 1, else if no same move p. 
	else if meet '.',  else if meet "*"
	when we meet "*", we go toward right not downside
	1.if p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1];
	2.if p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1];
	3.if p.charAt(j) == '*':
	3.1 if p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2] //in this case, a* only counts as empty
	3.2 if p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.':
		dp[i][j] = dp[i-1][j] //in this case, a* counts as multiple a
		or dp[i][j] = dp[i][j-1] // in this case, a* counts as single a
		or dp[i][j] = dp[i][j-2] // in this case, a* counts as empty
		O(n^2)

5.27
question 46 permutation
	use backtrack
	it's clear that the run time is O(n!), as it's permutation questions.
	in order to solve the permutation question, we need to use the recursive method.
	we could use the DFS. there are total n level, at every level i, there are i sub problem.
	at every subproblem we exchange once. we first set a border, before the border is the number which have 
	finished exchange, after the border is the content we need to exchange. 
	we swap, then going to next level, after we finish the all the swap, we returned to the origin.

question 47 permutation II
	same as the question 46, however it becomes harder as there are duplicate element appear. 
	we need to use the contains methed to cut the duplicate answer.

question 48 rotate image
	in this question, we are asked to rotate the image in place 90 degree. 
	the hardest part is that the question asked as not to create a new matrix.
	we know the change for is (i,j)-->(j,n-i-1)-->(n-i-1,n-j-1)-->(n-j-1,i)
	so we separate the image into four part and rotate it.

6.2 
question 23 merge k sorted lists
	normally, we could use the brute force way such as traversal all the number in the lists or we could 
	compare one by one. the run time complexity is O(k*N) k is the number of the lists.
	further we could use the merge sort method to decrease the run time. such as we meger two linked list 
	into one, and finally we got one linked list. this is a recursive way. there are logK level, k is the
	number of the linked lists. at every level we traversal all the n numbers once. so the run time is 
	O(logk*n)

question 30 Substring with concatenation of all words
	I'm going to use a way more stupid method to solve this problem. I just calculate the target string 
	length, then i move one character by one character to check whether the substring matches the array.
	in the subproblem, which i use for loop and create a helper array in order to check whether the two 
	string match

question 41 First Missing Positive 
	I'm going to create a helper array. suppose the nums array length is n. in the helper array, I set the 
	length as n+2, and I separate it into three part, if the number in nums <=0 do help[0]++, if nums>=n do
	help[n+1]++ or we just help[nums]++. this is the first for loop conplexity is O(n), as we traversal the
	nums once and put every number in right position. then I traversal the help array from small to big, 
	once we found there's a 0, which means we find the smallest positive number.


	         
